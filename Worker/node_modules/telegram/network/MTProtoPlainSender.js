"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MTProtoPlainSender = void 0;
/**
 *  This module contains the class used to communicate with Telegram's servers
 *  in plain text, when no authorization key has been created yet.
 */
const MTProtoState_1 = require("./MTProtoState");
const Helpers_1 = require("../Helpers");
const errors_1 = require("../errors");
const extensions_1 = require("../extensions");
/**
 * MTProto Mobile Protocol plain sender (https://core.telegram.org/mtproto/description#unencrypted-messages)
 */
class MTProtoPlainSender {
    /**
     * Initializes the MTProto plain sender.
     * @param connection connection: the Connection to be used.
     * @param loggers
     */
    constructor(connection, loggers) {
        this._state = new MTProtoState_1.MTProtoState(undefined, loggers);
        this._connection = connection;
    }
    /**
     * Sends and receives the result for the given request.
     * @param request
     */
    send(request) {
        return __awaiter(this, void 0, void 0, function* () {
            let body = request.getBytes();
            let msgId = this._state._getNewMsgId();
            const m = Helpers_1.toSignedLittleBuffer(msgId, 8);
            const b = Buffer.alloc(4);
            b.writeInt32LE(body.length, 0);
            const res = Buffer.concat([Buffer.concat([Buffer.alloc(8), m, b]), body]);
            yield this._connection.send(res);
            body = yield this._connection.recv();
            if (body.length < 8) {
                throw new errors_1.InvalidBufferError(body);
            }
            const reader = new extensions_1.BinaryReader(body);
            const authKeyId = reader.readLong();
            if (authKeyId.neq(BigInt(0))) {
                throw new Error('Bad authKeyId');
            }
            msgId = reader.readLong();
            if (msgId.eq(BigInt(0))) {
                throw new Error('Bad msgId');
            }
            /** ^ We should make sure that the read ``msg_id`` is greater
             * than our own ``msg_id``. However, under some circumstances
             * (bad system clock/working behind proxies) this seems to not
             * be the case, which would cause endless assertion errors.
             */
            const length = reader.readInt();
            if (length <= 0) {
                throw new Error('Bad length');
            }
            /**
             * We could read length bytes and use those in a new reader to read
             * the next TLObject without including the padding, but since the
             * reader isn't used for anything else after this, it's unnecessary.
             */
            return reader.tgReadObject();
        });
    }
}
exports.MTProtoPlainSender = MTProtoPlainSender;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTVRQcm90b1BsYWluU2VuZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vZ3JhbWpzL25ldHdvcmsvTVRQcm90b1BsYWluU2VuZGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBOzs7R0FHRztBQUNILGlEQUE0QztBQUU1Qyx3Q0FBZ0Q7QUFDaEQsc0NBQTZDO0FBQzdDLDhDQUEyQztBQUczQzs7R0FFRztBQUVILE1BQWEsa0JBQWtCO0lBSTNCOzs7O09BSUc7SUFDSCxZQUFZLFVBQWUsRUFBRSxPQUFZO1FBQ3JDLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSwyQkFBWSxDQUFDLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQTtRQUNsRCxJQUFJLENBQUMsV0FBVyxHQUFHLFVBQVUsQ0FBQTtJQUNqQyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0csSUFBSSxDQUFDLE9BQXVCOztZQUM5QixJQUFJLElBQUksR0FBRyxPQUFPLENBQUMsUUFBUSxFQUFFLENBQUE7WUFFN0IsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxZQUFZLEVBQUUsQ0FBQTtZQUN0QyxNQUFNLENBQUMsR0FBRyw4QkFBb0IsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUE7WUFDeEMsTUFBTSxDQUFDLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQTtZQUN6QixDQUFDLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUE7WUFFOUIsTUFBTSxHQUFHLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUE7WUFDekUsTUFBTSxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQTtZQUNoQyxJQUFJLEdBQUcsTUFBTSxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksRUFBRSxDQUFBO1lBQ3BDLElBQUksSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7Z0JBQ2pCLE1BQU0sSUFBSSwyQkFBa0IsQ0FBQyxJQUFJLENBQUMsQ0FBQTthQUNyQztZQUNELE1BQU0sTUFBTSxHQUFHLElBQUkseUJBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQTtZQUNyQyxNQUFNLFNBQVMsR0FBRyxNQUFNLENBQUMsUUFBUSxFQUFFLENBQUE7WUFDbkMsSUFBSSxTQUFTLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO2dCQUMxQixNQUFNLElBQUksS0FBSyxDQUFDLGVBQWUsQ0FBQyxDQUFBO2FBQ25DO1lBQ0QsS0FBSyxHQUFHLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQTtZQUN6QixJQUFJLEtBQUssQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUU7Z0JBQ3JCLE1BQU0sSUFBSSxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUE7YUFDL0I7WUFDRDs7OztlQUlHO1lBRUgsTUFBTSxNQUFNLEdBQUcsTUFBTSxDQUFDLE9BQU8sRUFBRSxDQUFBO1lBQy9CLElBQUksTUFBTSxJQUFJLENBQUMsRUFBRTtnQkFDYixNQUFNLElBQUksS0FBSyxDQUFDLFlBQVksQ0FBQyxDQUFBO2FBQ2hDO1lBQ0Q7Ozs7ZUFJRztZQUNILE9BQU8sTUFBTSxDQUFDLFlBQVksRUFBRSxDQUFBO1FBQ2hDLENBQUM7S0FBQTtDQUVKO0FBM0RELGdEQTJEQyJ9