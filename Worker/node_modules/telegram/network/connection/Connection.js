"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObfuscatedConnection = exports.PacketCodec = exports.Connection = void 0;
const extensions_1 = require("../../extensions");
const extensions_2 = require("../../extensions");
const Helpers_1 = require("../../Helpers");
/**
 * The `Connection` class is a wrapper around ``asyncio.open_connection``.
 *
 * Subclasses will implement different transport modes as atomic operations,
 * which this class eases doing since the exposed interface simply puts and
 * gets complete data payloads to and from queues.
 *
 * The only error that will raise from send and receive methods is
 * ``ConnectionError``, which will raise when attempting to send if
 * the client is disconnected (includes remote disconnections).
 */
class Connection {
    constructor(ip, port, dcId, loggers) {
        this._ip = ip;
        this._port = port;
        this._dcId = dcId;
        this._log = loggers;
        this._connected = false;
        this._sendTask = undefined;
        this._recvTask = undefined;
        this._codec = undefined;
        this._obfuscation = undefined; // TcpObfuscated and MTProxy
        this._sendArray = new extensions_2.AsyncQueue();
        this._recvArray = new extensions_2.AsyncQueue();
        this.socket = Helpers_1.IS_NODE ? new extensions_1.PromisedNetSockets() : new extensions_1.PromisedWebSockets();
        //this.socket = new PromisedWebSockets()
    }
    _connect() {
        return __awaiter(this, void 0, void 0, function* () {
            this._log.debug('Connecting');
            this._codec = new this.PacketCodecClass(this);
            yield this.socket.connect(this._port, this._ip);
            this._log.debug('Finished connecting');
            // await this.socket.connect({host: this._ip, port: this._port});
            yield this._initConn();
        });
    }
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._connect();
            this._connected = true;
            this._sendTask = this._sendLoop();
            this._recvTask = this._recvLoop();
        });
    }
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            this._connected = false;
            yield this._recvArray.push(undefined);
            yield this.socket.close();
        });
    }
    send(data) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._connected) {
                // this will stop the current loop
                // @ts-ignore
                yield this._sendArray(undefined);
                throw new Error('Not connected');
            }
            yield this._sendArray.push(data);
        });
    }
    recv() {
        return __awaiter(this, void 0, void 0, function* () {
            while (this._connected) {
                const result = yield this._recvArray.pop();
                // undefined = sentinel value = keep trying
                if (result && result.length) {
                    return result;
                }
            }
            throw new Error('Not connected');
        });
    }
    _sendLoop() {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO handle errors
            try {
                while (this._connected) {
                    const data = yield this._sendArray.pop();
                    if (!data) {
                        this._sendTask = undefined;
                        return;
                    }
                    yield this._send(data);
                }
            }
            catch (e) {
                this._log.info('The server closed the connection while sending');
            }
        });
    }
    _recvLoop() {
        return __awaiter(this, void 0, void 0, function* () {
            let data;
            while (this._connected) {
                try {
                    data = yield this._recv();
                    if (!data) {
                        throw new Error('no data received');
                    }
                }
                catch (e) {
                    this._log.info('connection closed');
                    //await this._recvArray.push()
                    console.log(e);
                    this.disconnect();
                    return;
                }
                yield this._recvArray.push(data);
            }
        });
    }
    _initConn() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._codec.tag) {
                yield this.socket.write(this._codec.tag);
            }
        });
    }
    _send(data) {
        return __awaiter(this, void 0, void 0, function* () {
            const encodedPacket = this._codec.encodePacket(data);
            this.socket.write(encodedPacket);
        });
    }
    _recv() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this._codec.readPacket(this.socket);
        });
    }
    toString() {
        return `${this._ip}:${this._port}/${this.constructor.name.replace('Connection', '')}`;
    }
}
exports.Connection = Connection;
class ObfuscatedConnection extends Connection {
    constructor() {
        super(...arguments);
        this.ObfuscatedIO = undefined;
    }
    _initConn() {
        return __awaiter(this, void 0, void 0, function* () {
            this._obfuscation = new this.ObfuscatedIO(this);
            this.socket.write(this._obfuscation.header);
        });
    }
    _send(data) {
        return __awaiter(this, void 0, void 0, function* () {
            this._obfuscation.write(this._codec.encodePacket(data));
        });
    }
    _recv() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this._codec.readPacket(this._obfuscation);
        });
    }
}
exports.ObfuscatedConnection = ObfuscatedConnection;
class PacketCodec {
    constructor(connection) {
        this._conn = connection;
    }
    encodePacket(data) {
        throw new Error('Not Implemented');
        // Override
    }
    readPacket(reader) {
        return __awaiter(this, void 0, void 0, function* () {
            // override
            throw new Error('Not Implemented');
        });
    }
}
exports.PacketCodec = PacketCodec;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29ubmVjdGlvbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2dyYW1qcy9uZXR3b3JrL2Nvbm5lY3Rpb24vQ29ubmVjdGlvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFDQSxpREFBc0U7QUFDdEUsaURBQTJDO0FBQzNDLDJDQUFxQztBQUVyQzs7Ozs7Ozs7OztHQVVHO0FBQ0gsTUFBTSxVQUFVO0lBZ0JaLFlBQVksRUFBVSxFQUFFLElBQVksRUFBRSxJQUFZLEVBQUUsT0FBWTtRQUM1RCxJQUFJLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQztRQUNkLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDO1FBQ2xCLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDO1FBQ2xCLElBQUksQ0FBQyxJQUFJLEdBQUcsT0FBTyxDQUFDO1FBQ3BCLElBQUksQ0FBQyxVQUFVLEdBQUcsS0FBSyxDQUFDO1FBQ3hCLElBQUksQ0FBQyxTQUFTLEdBQUcsU0FBUyxDQUFDO1FBQzNCLElBQUksQ0FBQyxTQUFTLEdBQUcsU0FBUyxDQUFDO1FBQzNCLElBQUksQ0FBQyxNQUFNLEdBQUcsU0FBUyxDQUFDO1FBQ3hCLElBQUksQ0FBQyxZQUFZLEdBQUcsU0FBUyxDQUFDLENBQUMsNEJBQTRCO1FBQzNELElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSx1QkFBVSxFQUFFLENBQUM7UUFDbkMsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLHVCQUFVLEVBQUUsQ0FBQztRQUNuQyxJQUFJLENBQUMsTUFBTSxHQUFHLGlCQUFPLENBQUMsQ0FBQyxDQUFDLElBQUksK0JBQWtCLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSwrQkFBa0IsRUFBRSxDQUFBO1FBRTNFLHdDQUF3QztJQUM1QyxDQUFDO0lBRUssUUFBUTs7WUFDVixJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsQ0FBQztZQUM5QixJQUFJLENBQUMs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