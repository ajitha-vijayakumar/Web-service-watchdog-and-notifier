"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MTProtoSender = void 0;
/**
 * MTProto Mobile Protocol sender
 * (https://core.telegram.org/mtproto/description)
 * This class is responsible for wrapping requests into `TLMessage`'s,
 * sending them over the network and receiving them in a safe manner.
 *
 * Automatic reconnection due to temporary network issues is a concern
 * for this class as well, including retry of messages that could not
 * be sent successfully.
 *
 * A new authorization key will be generated on connection if no other
 * key exists yet.
 */
const AuthKey_1 = require("../crypto/AuthKey");
const MTProtoState_1 = require("./MTProtoState");
const extensions_1 = require("../extensions");
const extensions_2 = require("../extensions");
const core_1 = require("../tl/core");
const tl_1 = require("../tl");
const big_integer_1 = __importDefault(require("big-integer"));
const Helpers_1 = require("../Helpers");
const RequestState_1 = require("./RequestState");
const Authenticator_1 = require("./Authenticator");
const MTProtoPlainSender_1 = require("./MTProtoPlainSender");
const errors_1 = require("../errors");
const _1 = require("./");
{
}
class MTProtoSender {
    /**
     * @param authKey
     * @param opts
     */
    constructor(authKey, opts) {
        const args = Object.assign(Object.assign({}, MTProtoSender.DEFAULT_OPTIONS), opts);
        this._connection = undefined;
        this._log = args.logger;
        this._dcId = args.dcId;
        this._retries = args.retries;
        this._delay = args.delay;
        this._autoReconnect = args.autoReconnect;
        this._connectTimeout = args.connectTimeout;
        this._authKeyCallback = args.authKeyCallback;
        this._updateCallback = args.updateCallback;
        this._autoReconnectCallback = args.autoReconnectCallback;
        this._isMainSender = args.isMainSender;
        this._senderCallback = args.senderCallback;
        /**
         * Whether the user has explicitly connected or disconnected.
         *
         * If a disconnection happens for any other reason and it
         * was *not* user action then the pending messages won't
         * be cleared but on explicit user disconnection all the
         * pending futures should be cancelled.
         */
        this._userConnected = false;
        this._reconnecting = false;
        this._disconnected = true;
        /**
         * We need to join the loops upon disconnection
         */
        this._sendLoopHandle = null;
        this._recvLoopHandle = null;
        /**
         * Preserving the references of the AuthKey and state is important
         */
        this.authKey = authKey || new AuthKey_1.AuthKey();
        this._state = new MTProtoState_1.MTProtoState(this.authKey, this._log);
        /**
         * Outgoing messages are put in a queue and sent in a batch.
         * Note that here we're also storing their ``_RequestState``.
         */
        this._sendQueue = new extensions_2.MessagePacker(this._state, this._log);
        /**
         * Sent states are remembered until a response is received.
         */
        this._pendingState = new Map();
        /**
         * Responses must be acknowledged, and we can also batch these.
         */
        this._pendingAck = new Set();
        /**
         * Similar to pending_messages but only for the last acknowledges.
         * These can't go in pending_messages because no acknowledge for them
         * is received, but we may still need to resend their state on bad salts.
         */
        this._lastAcks = [];
        /**
         * Jump table from response ID to method that handles it
         */
        this._handlers = {
            [core_1.RPCResult.CONSTRUCTOR_ID.toString()]: this._handleRPCResult.bind(this),
            [core_1.MessageContainer.CONSTRUCTOR_ID.toString()]: this._handleContainer.bind(this),
            [core_1.GZIPPacked.CONSTRUCTOR_ID.toString()]: this._handleGzipPacked.bind(this),
            [tl_1.Api.Pong.CONSTRUCTOR_ID.toString()]: this._handlePong.bind(this),
            [tl_1.Api.BadServerSalt.CONSTRUCTOR_ID.toString()]: this._handleBadServerSalt.bind(this),
            [tl_1.Api.BadMsgNotification.CONSTRUCTOR_ID.toString()]: this._handleBadNotification.bind(this),
            [tl_1.Api.MsgDetailedInfo.CONSTRUCTOR_ID.toString()]: this._handleDetailedInfo.bind(this),
            [tl_1.Api.MsgNewDetailedInfo.CONSTRUCTOR_ID.toString()]: this._handleNewDetailedInfo.bind(this),
            [tl_1.Api.NewSessionCreated.CONSTRUCTOR_ID.toString()]: this._handleNewSessionCreated.bind(this),
            [tl_1.Api.MsgsAck.CONSTRUCTOR_ID.toString()]: this._handleAck.bind(this),
            [tl_1.Api.FutureSalts.CONSTRUCTOR_ID.toString()]: this._handleFutureSalts.bind(this),
            [tl_1.Api.MsgsStateReq.CONSTRUCTOR_ID.toString()]: this._handleStateForgotten.bind(this),
            [tl_1.Api.MsgResendReq.CONSTRUCTOR_ID.toString()]: this._handleStateForgotten.bind(this),
            [tl_1.Api.MsgsAllInfo.CONSTRUCTOR_ID.toString()]: this._handleMsgAll.bind(this),
        };
    }
    set dcId(dcId) {
        this._dcId = dcId;
    }
    get dcId() {
        return this._dcId;
    }
    // Public API
    /**
     * Connects to the specified given connection using the given auth key.
     * @param connection
     * @param eventDispatch {function}
     * @returns {Promise<boolean>}
     */
    connect(connection, eventDispatch) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._userConnected) {
                this._log.info('User is already connected!');
                return false;
            }
            this._connection = connection;
            const retries = this._retries;
            for (let attempt = 0; attempt < retries; attempt++) {
                try {
                    yield this._connect();
                    break;
                }
                catch (e) {
                    if (attempt === 0 && eventDispatch) {
                        eventDispatch({ update: new _1.UpdateConnectionState(-1) });
                    }
                    console.dir(e);
                    this._log.error('WebSocket connection failed attempt : ' + (attempt + 1));
                    yield Helpers_1.sleep(this._delay);
                }
            }
            return true;
        });
    }
    isConnected() {
        return this._userConnected;
    }
    /**
     * Cleanly disconnects the instance from the network, cancels
     * all pending requests, and closes the send and receive loops.
     */
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._disconnect();
        });
    }
    /**
     *
     This method enqueues the given request to be sent. Its send
     state will be saved until a response arrives, and a ``Future``
     that will be resolved when the response arrives will be returned:

     .. code-block:: javascript

     async def method():
     # Sending (enqueued for the send loop)
     future = sender.send(request)
     # Receiving (waits for the receive loop to read the result)
     result = await future

     Designed like this because Telegram may send the response at
     any point, and it can send other items while one waits for it.
     Once the response for this future arrives, it is set with the
     received result, quite similar to how a ``receive()`` call
     would otherwise work.

     Since the receiving part is "built in" the future, it's
     impossible to await receive a result that was never sent.
     * @param request
     * @returns {RequestState}
     */
    send(request) {
        if (!this._userConnected) {
            throw new Error('Cannot send requests while disconnected');
        }
        const state = new RequestState_1.RequestState(request);
        this._sendQueue.append(state);
        return state.promise;
    }
    /**
     * Performs the actual connection, retrying, generating the
     * authorization key if necessary, and starting the send and
     * receive loops.
     * @returns {Promise<void>}
     * @private
     */
    _connect() {
        return __awaiter(this, void 0, void 0, function* () {
            this._log.info('Connecting to {0}...'.replace('{0}', this._connection.toString()));
            yield this._connection.connect();
            this._log.debug('Connection success!');
            //process.exit(0)
            if (!this.authKey.getKey()) {
                const plain = new MTProtoPlainSender_1.MTProtoPlainSender(this._connection, this._log);
                this._log.debug('New auth_key attempt ...');
                const res = yield Authenticator_1.doAuthentication(plain, this._log);
                this._log.debug('Generated new auth_key successfully');
                yield this.authKey.setKey(res.authKey);
                this._state.timeOffset = res.timeOffset;
                /**
                 * This is *EXTREMELY* important since we don't control
                 * external references to the authorization key, we must
                 * notify whenever we change it. This is crucial when we
                 * switch to different data centers.
                 */
                if (this._authKeyCallback) {
                    yield this._authKeyCallback(this.authKey, this._dcId);
                }
            }
            else {
                this._log.debug('Already have an auth key ...');
            }
            this._userConnected = true;
            this._reconnecting = false;
            this._log.debug('Starting receive loop');
            this._recvLoopHandle = this._recvLoop();
            this._log.debug('Starting send loop');
            this._sendLoopHandle = this._sendLoop();
            // _disconnected only completes after manual disconnection
            // or errors after which the sender cannot continue such
            // as failing to reconnect or any unexpected error.
            this._log.info('Connection to %s complete!'.replace('%s', this._connection.toString()));
        });
    }
    _disconnect(error = null) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._connection === null) {
                this._log.info('Not disconnecting (already have no connection)');
                return;
            }
            if (this._updateCallback) {
                this._updateCallback(-1);
            }
            this._log.info('Disconnecting from %s...'.replace('%s', this._connection.toString()));
            this._userConnected = false;
            this._log.debug('Closing current connection...');
            yield this._connection.disconnect();
        });
    }
    /**
     * This loop is responsible for popping items off the send
     * queue, encrypting them, and sending them over the network.
     * Besides `connect`, only this method ever sends data.
     * @returns {Promise<void>}
     * @private
     */
    _sendLoop() {
        return __awaiter(this, void 0, void 0, function* () {
            this._sendQueue = new extensions_2.MessagePacker(this._state, this._log);
            while (this._userConnected && !this._reconnecting) {
                if (this._pendingAck.size) {
                    const ack = new RequestState_1.RequestState(new tl_1.Api.MsgsAck({ msgIds: Array(...this._pendingAck) }));
                    this._sendQueue.append(ack);
                    this._lastAcks.push(ack);
                    this._pendingAck.clear();
                }
                this._log.debug('Waiting for messages to send...' + this._reconnecting);
                // TODO Wait for the connection send queue to be empty?
                // This means that while it's not empty we can wait for
                // more messages to be added to the send queue.
                const res = yield this._sendQueue.get();
                if (this._reconnecting) {
                    this._log.debug('Reconnecting. will stop loop');
                    return;
                }
                if (!res) {
                    this._log.debug('Empty result. will stop loop');
                    continue;
                }
                let data = res.data;
                const batch = res.batch;
                this._log.debug(`Encrypting ${batch.length} message(s) in ${data.length} bytes for sending`);
                data = yield this._state.encryptMessageData(data);
                try {
                    yield this._connection.send(data);
                }
                catch (e) {
                    this._log.error(e);
                    this._log.info('Connection closed while sending data');
                    return;
                }
                for (const state of batch) {
                    if (!Array.isArray(state)) {
                        if (state.request.classType === 'request') {
                            this._pendingState.set(state.msgId.toString(), state);
                        }
                    }
                    else {
                        for (const s of state) {
                            if (s.request.classType === 'request') {
                                this._pendingState.set(s.msgId.toString(), s);
                            }
                        }
                    }
                }
                this._log.debug('Encrypted messages put in a queue to be sent');
            }
        });
    }
    _recvLoop() {
        return __awaiter(this, void 0, void 0, function* () {
            let body;
            let message;
            while (this._userConnected && !this._reconnecting) {
                // this._log.debug('Receiving items from the network...');
                this._log.debug('Receiving items from the network...');
                try {
                    body = yield this._connection.recv();
                }
                catch (e) {
                    // this._log.info('Connection closed while receiving data');
                    this._log.warn('Connection closed while receiving data');
                    this._startReconnect();
                    return;
                }
                try {
                    message = yield this._state.decryptMessageData(body);
                }
                catch (e) {
                    if (e instanceof errors_1.TypeNotFoundError) {
                        // Received object which we don't know how to deserialize
                        this._log.info(`Type ${e.invalidConstructorId} not found, remaining data ${e.remaining}`);
                        continue;
                    }
                    else if (e instanceof errors_1.SecurityError) {
                        // A step while decoding had the incorrect data. This message
                        // should not be considered safe and it should be ignored.
                        this._log.warn(`Security error while unpacking a received message: ${e}`);
                        continue;
                    }
                    else if (e instanceof errors_1.InvalidBufferError) {
                        this._log.info('Broken authorization key; resetting');
                        if (this._updateCallback && this._isMainSender) {
                            // 0 == broken
                            this._updateCallback(0);
                        }
                        else if (this._senderCallback && !this._isMainSender) {
                            // Deletes the current sender from the object
                            this._senderCallback(this._dcId);
                        }
                        // We don't really need to do this if we're going to sign in again
                        /*await this.authKey.setKey(null)
    
                        if (this._authKeyCallback) {
                            await this._authKeyCallback(null)
                        }*/
                        // We can disconnect at sign in
                        /* await this.disconnect()
                        */
                        return;
                    }
                    else {
                        this._log.error('Unhandled error while receiving data');
                        this._log.error(e);
                        console.log(e);
                        this._startReconnect();
                        return;
                    }
                }
                try {
                    yield this._processMessage(message);
                }
                catch (e) {
                    this._log.error('Unhandled error while receiving data');
                    console.log(e);
                    this._log.error(e);
                }
            }
        });
    }
    // Response Handlers
    /**
     * Adds the given message to the list of messages that must be
     * acknowledged and dispatches control to different ``_handle_*``
     * method based on its type.
     * @param message
     * @returns {Promise<void>}
     * @private
     */
    _processMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            this._pendingAck.add(message.msgId);
            // eslint-disable-next-line require-atomic-updates
            message.obj = yield message.obj;
            let handler = this._handlers[message.obj.CONSTRUCTOR_ID.toString()];
            if (!handler) {
                handler = this._handleUpdate.bind(this);
            }
            yield handler(message);
        });
    }
    /**
     * Pops the states known to match the given ID from pending messages.
     * This method should be used when the response isn't specific.
     * @param msgId
     * @returns {*[]}
     * @private
     */
    _popStates(msgId) {
        let state = this._pendingState.get(msgId.toString());
        if (state) {
            this._pendingState.delete(msgId.toString());
            return [state];
        }
        const toPop = [];
        for (const state of Object.values(this._pendingState)) {
            if (state.containerId && state.containerId.equals(msgId)) {
                toPop.push(state.msgId);
            }
        }
        if (toPop.length) {
            const temp = [];
            for (const x of toPop) {
                temp.push(this._pendingState.get(x));
                this._pendingState.delete(x);
            }
            return temp;
        }
        for (const ack of this._lastAcks) {
            if (ack.msgId === msgId) {
                return [ack];
            }
        }
        return [];
    }
    /**
     * Handles the result for Remote Procedure Calls:
     * rpc_result#f35c6d01 req_msg_id:long result:bytes = RpcResult;
     * This is where the future results for sent requests are set.
     * @param message
     * @returns {Promise<void>}
     * @private
     */
    _handleRPCResult(message) {
        const RPCResult = message.obj;
        const state = this._pendingState.get(RPCResult.reqMsgId.toString());
        if (state) {
            this._pendingState.delete(RPCResult.reqMsgId.toString());
        }
        this._log.debug(`Handling RPC result for message ${RPCResult.reqMsgId}`);
        if (!state) {
            // TODO We should not get responses to things we never sent
            // However receiving a File() with empty bytes is "common".
            // See #658, #759 and #958. They seem to happen in a container
            // which contain the real response right after.
            try {
                const reader = new extensions_1.BinaryReader(RPCResult.body);
                if (!(reader.tgReadObject() instanceof tl_1.Api.upload.File)) {
                    throw new Error('Not an upload.File');
                }
            }
            catch (e) {
                this._log.error(e);
                if (e instanceof errors_1.TypeNotFoundError) {
                    this._log.info(`Received response without parent request: ${RPCResult.body}`);
                    return;
                }
                else {
                    throw e;
                }
            }
            return;
        }
        if (RPCResult.error && state.msgId) {
            const error = errors_1.RPCMessageToError(RPCResult.error, state.request);
            this._sendQueue.append(new RequestState_1.RequestState(new tl_1.Api.MsgsAck({ msgIds: [state.msgId] })));
            state.reject(error);
        }
        else {
            const reader = new extensions_1.BinaryReader(RPCResult.body);
            const read = state.request.readResult(reader);
            //console.log("patcfh goes here ?", read);
            state.resolve(read);
        }
    }
    /**
     * Processes the inner messages of a container with many of them:
     * msg_container#73f1f8dc messages:vector<%Message> = MessageContainer;
     * @param message
     * @returns {Promise<void>}
     * @private
     */
    _handleContainer(message) {
        return __awaiter(this, void 0, void 0, function* () {
            this._log.debug('Handling container');
            for (const innerMessage of message.obj.messages) {
                yield this._processMessage(innerMessage);
            }
        });
    }
    /**
     * Unpacks the data from a gzipped object and processes it:
     * gzip_packed#3072cfa1 packed_data:bytes = Object;
     * @param message
     * @returns {Promise<void>}
     * @private
     */
    _handleGzipPacked(message) {
        return __awaiter(this, void 0, void 0, function* () {
            this._log.debug('Handling gzipped data');
            const reader = new extensions_1.BinaryReader(message.obj.data);
            message.obj = reader.tgReadObject();
            yield this._processMessage(message);
        });
    }
    _handleUpdate(message) {
        return __awaiter(this, void 0, void 0, function* () {
            if (message.obj.SUBCLASS_OF_ID !== 0x8af52aac) {
                // crc32(b'Updates')
                this._log.warn(`Note: ${message.obj.className} is not an update, not dispatching it`);
                return;
            }
            this._log.debug('Handling update ' + message.obj.className);
            if (this._updateCallback) {
                this._updateCallback(message.obj);
            }
        });
    }
    /**
     * Handles pong results, which don't come inside a ``RPCResult``
     * but are still sent through a request:
     * pong#347773c5 msg_id:long ping_id:long = Pong;
     * @param message
     * @returns {Promise<void>}
     * @private
     */
    _handlePong(message) {
        return __awaiter(this, void 0, void 0, function* () {
            const pong = message.obj;
            this._log.debug(`Handling pong for message ${pong.msgId}`);
            const state = this._pendingState.get(pong.msgId);
            this._pendingState.delete(pong.msgId);
            // Todo Check result
            if (state) {
                state.resolve(pong);
            }
        });
    }
    /**
     * Corrects the currently used server salt to use the right value
     * before enqueuing the rejected message to be re-sent:
     * bad_server_salt#edab447b bad_msg_id:long bad_msg_seqno:int
     * error_code:int new_server_salt:long = BadMsgNotification;
     * @param message
     * @returns {Promise<void>}
     * @private
     */
    _handleBadServerSalt(message) {
        return __awaiter(this, void 0, void 0, function* () {
            const badSalt = message.obj;
            this._log.debug(`Handling bad salt for message ${badSalt.badMsgId}`);
            this._state.salt = badSalt.newServerSalt;
            const states = this._popStates(badSalt.badMsgId);
            this._sendQueue.extend(states);
            this._log.debug(`${states.length} message(s) will be resent`);
        });
    }
    /**
     * Adjusts the current state to be correct based on the
     * received bad message notification whenever possible:
     * bad_msg_notification#a7eff811 bad_msg_id:long bad_msg_seqno:int
     * error_code:int = BadMsgNotification;
     * @param message
     * @returns {Promise<void>}
     * @private
     */
    _handleBadNotification(message) {
        return __awaiter(this, void 0, void 0, function* () {
            const badMsg = message.obj;
            const states = this._popStates(badMsg.badMsgId);
            this._log.debug(`Handling bad msg ${JSON.stringify(badMsg)}`);
            if ([16, 17].includes(badMsg.errorCode)) {
                // Sent msg_id too low or too high (respectively).
                // Use the current msg_id to determine the right time offset.
                const to = this._state.updateTimeOffset(big_integer_1.default(message.msgId));
                this._log.info(`System clock is wrong, set time offset to ${to}s`);
            }
            else if (badMsg.errorCode === 32) {
                // msg_seqno too low, so just pump it up by some "large" amount
                // TODO A better fix would be to start with a new fresh session ID
                this._state._sequence += 64;
            }
            else if (badMsg.errorCode === 33) {
                // msg_seqno too high never seems to happen but just in case
                this._state._sequence -= 16;
            }
            else {
                for (const state of states) {
                    state.reject(new errors_1.BadMessageError(state.request, badMsg.errorCode));
                }
                return;
            }
            // Messages are to be re-sent once we've corrected the issue
            this._sendQueue.extend(states);
            this._log.debug(`${states.length} messages will be resent due to bad msg`);
        });
    }
    /**
     * Updates the current status with the received detailed information:
     * msg_detailed_info#276d3ec6 msg_id:long answer_msg_id:long
     * bytes:int status:int = MsgDetailedInfo;
     * @param message
     * @returns {Promise<void>}
     * @private
     */
    _handleDetailedInfo(message) {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO https://goo.gl/VvpCC6
            const msgId = message.obj.answerMsgId;
            this._log.debug(`Handling detailed info for message ${msgId}`);
            this._pendingAck.add(msgId);
        });
    }
    /**
     * Updates the current status with the received detailed information:
     * msg_new_detailed_info#809db6df answer_msg_id:long
     * bytes:int status:int = MsgDetailedInfo;
     * @param message
     * @returns {Promise<void>}
     * @private
     */
    _handleNewDetailedInfo(message) {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO https://goo.gl/VvpCC6
            const msgId = message.obj.answerMsgId;
            this._log.debug(`Handling new detailed info for message ${msgId}`);
            this._pendingAck.add(msgId);
        });
    }
    /**
     * Updates the current status with the received session information:
     * new_session_created#9ec20908 first_msg_id:long unique_id:long
     * server_salt:long = NewSession;
     * @param message
     * @returns {Promise<void>}
     * @private
     */
    _handleNewSessionCreated(message) {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO https://goo.gl/LMyN7A
            this._log.debug('Handling new session created');
            this._state.salt = message.obj.serverSalt;
        });
    }
    /**
     * Handles a server acknowledge about our messages. Normally
     * these can be ignored except in the case of ``auth.logOut``:
     *
     *     auth.logOut#5717da40 = Bool;
     *
     * Telegram doesn't seem to send its result so we need to confirm
     * it manually. No other request is known to have this behaviour.

     * Since the ID of sent messages consisting of a container is
     * never returned (unless on a bad notification), this method
     * also removes containers messages when any of their inner
     * messages are acknowledged.

     * @param message
     * @returns {Promise<void>}
     * @private
     */
    _handleAck(message) {
        return __awaiter(this, void 0, void 0, function* () {
            const ack = message.obj;
            this._log.debug(`Handling acknowledge for ${ack.msgIds}`);
            for (const msgId of ack.msgIds) {
                const state = this._pendingState.get(msgId);
                if (state && state.request instanceof tl_1.Api.auth.LogOut) {
                    this._pendingState.delete(msgId);
                    state.resolve(true);
                }
            }
        });
    }
    /**
     * Handles future salt results, which don't come inside a
     * ``rpc_result`` but are still sent through a request:
     *     future_salts#ae500895 req_msg_id:long now:int
     *     salts:vector<future_salt> = FutureSalts;
     * @param message
     * @returns {Promise<void>}
     * @private
     */
    _handleFutureSalts(message) {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO save these salts and automatically adjust to the
            // correct one whenever the salt in use expires.
            this._log.debug(`Handling future salts for message ${message.msgId}`);
            const state = this._pendingState.get(message.msgId.toString());
            if (state) {
                this._pendingState.delete(message.msgId.toString());
                state.resolve(message.obj);
            }
        });
    }
    /**
     * Handles both :tl:`MsgsStateReq` and :tl:`MsgResendReq` by
     * enqueuing a :tl:`MsgsStateInfo` to be sent at a later point.
     * @param message
     * @returns {Promise<void>}
     * @private
     */
    _handleStateForgotten(message) {
        return __awaiter(this, void 0, void 0, function* () {
            this._sendQueue.append(new RequestState_1.RequestState(new tl_1.Api.MsgsStateInfo({
                reqMsgId: message.msgId,
                info: String.fromCharCode(1).repeat(message.obj.msgIds)
            })));
        });
    }
    /**
     * Handles :tl:`MsgsAllInfo` by doing nothing (yet).
     * @param message
     * @returns {Promise<void>}
     * @private
     */
    _handleMsgAll(message) {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    _startReconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._userConnected && !this._reconnecting) {
                this._reconnecting = true;
                // TODO Should we set this?
                // this._user_connected = false
                this._log.info('Started reconnecting');
                this._reconnect();
            }
        });
    }
    _reconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            this._log.debug('Closing current connection...');
            try {
                yield this.disconnect();
            }
            catch (err) {
                this._log.warn(err);
            }
            // @ts-ignore
            this._sendQueue.append(null);
            this._state.reset();
            const retries = this._retries;
            for (let attempt = 0; attempt < retries; attempt++) {
                try {
                    yield this._connect();
                    // uncomment this if you want to resend
                    this._sendQueue.extend(Array.from(this._pendingState.values()));
                    this._pendingState = new Map();
                    if (this._autoReconnectCallback) {
                        yield this._autoReconnectCallback();
                    }
                    if (this._updateCallback) {
                        this._updateCallback(1);
                    }
                    break;
                }
                catch (e) {
                    this._log.error('WebSocket connection failed attempt : ' + (attempt + 1));
                    console.log(e);
                    yield Helpers_1.sleep(this._delay);
                }
            }
        });
    }
}
exports.MTProtoSender = MTProtoSender;
MTProtoSender.DEFAULT_OPTIONS = {
    logger: null,
    retries: Infinity,
    delay: 2000,
    autoReconnect: true,
    connectTimeout: null,
    authKeyCallback: null,
    updateCallback: null,
    autoReconnectCallback: null,
    isMainSender: null,
    senderCallback: null,
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTVRQcm90b1NlbmRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL2dyYW1qcy9uZXR3b3JrL01UUHJvdG9TZW5kZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7OztHQVlHO0FBQ0gsK0NBQTBDO0FBQzFDLGlEQUE0QztBQUM1Qyw4Q0FBNEM7QUFDNUMsOENBQThDO0FBQzlDLHFDQUE4RTtBQUM5RSw4QkFBMEI7QUFDMUIsOERBQWdDO0FBQ2hDLHdDQUFpQztBQUNqQyxpREFBNEM7QUFDNUMsbURBQWlEO0FBQ2pELDZEQUF5RDtBQUN6RCxzQ0FBZ0g7QUFDaEgseUJBQXFEO0FBZ0JyRDtDQUVDO0FBRUQsTUFBYSxhQUFhO0lBc0N0Qjs7O09BR0c7SUFDSCxZQUFZLE9BQTRCLEVBQUUsSUFBcUI7UUFDM0QsTUFBTSxJQUFJLG1DQUFPLGFBQWEsQ0FBQyxlQUFlLEdBQUssSUFBSSxDQUFDLENBQUM7UUFDekQsSUFBSSxDQUFDLFdBQVcsR0FBRyxTQUFTLENBQUM7UUFDN0IsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO1FBQ3hCLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQztRQUN2QixJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUM7UUFDN0IsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDO1FBQ3pCLElBQUksQ0FBQyxjQUFjLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQztRQUN6QyxJQUFJLENBQUMsZUFBZSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUM7UUFDM0MsSUFBSSxDQUFDLGdCQUFnQixHQUFHLElBQUksQ0FBQyxlQUFlLENBQUM7UUFDN0MsSUFBSSxDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDO1FBQzNDLElBQUksQ0FBQyxzQkFBc0IsR0FBRyxJQUFJLENB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