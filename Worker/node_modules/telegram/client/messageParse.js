"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports._parseMessageText = exports._replaceWithMention = exports.DEFAULT_DELIMITERS = void 0;
const Utils_1 = require("../Utils");
const tl_1 = require("../tl");
exports.DEFAULT_DELIMITERS = {
    '**': tl_1.Api.MessageEntityBold,
    '__': tl_1.Api.MessageEntityItalic,
    '~~': tl_1.Api.MessageEntityStrike,
    '`': tl_1.Api.MessageEntityCode,
    '```': tl_1.Api.MessageEntityPre
};
function _replaceWithMention(client, entities, i, user) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            entities[i] = new tl_1.Api.InputMessageEntityMentionName({
                offset: entities[i].offset,
                length: entities[i].length,
                userId: yield client.getInputEntity(user)
            });
            return true;
        }
        catch (e) {
            return false;
        }
    });
}
exports._replaceWithMention = _replaceWithMention;
function _parseMessageText(client, message, parseMode) {
    if (!parseMode) {
        parseMode = client.parseMode;
    }
    else if (typeof parseMode === "string") {
        parseMode = Utils_1.sanitizeParseMode(parseMode);
    }
    if (!parseMode) {
        return [message, []];
    }
    return parseMode.parse(message);
}
exports._parseMessageText = _parseMessageText;
/* TODO make your own smh
export function _getResponseMessage(request: Api.AnyRequest, result: Api.TypeUpdates, inputChat: Api.TypeInputPeer) {
    let updates = [];
    let entities = new Map();
    if (result instanceof Api.UpdateShort) {
        updates = [result.update]
    } else if (result instanceof Api.Updates || result instanceof Api.UpdatesCombined) {
        updates = result.updates;
        for (const x of [...result.users, ...result.chats]) {
            entities.set(getPeerId(x), x);
        }
    } else {
        return;
    }
    const randomToId = new Map();
    const idToMessage = new Map();
    const schedToMessage = new Map();
    for (const update of updates) {
        if (update instanceof Api.UpdateMessageID) {
            randomToId.set(update.randomId, update.id);
        } else if (update instanceof Api.UpdateNewChannelMessage || update instanceof Api.UpdateNewMessage) {
            // @ts-ignore
            // TODO update.message._finishInit(this, entities, inputChat);
            if ('randomId' in request || isArrayLike(request)) {
                idToMessage.set(update.message.id, update.message);
            } else {
                return update.message;
            }
        } else if (update instanceof Api.UpdateEditMessage && 'peer' in request && _entityType(request.peer) != _EntityType.CHANNEL) {
            // @ts-ignore
            // TODO update.message._finishInit(this, entities, inputChat);
            if ('randomId' in request) {
                idToMessage.set(update.message.id, update.message);
            } else if ('id' in request && request.id === update.message.id) {
                return update.message;
            }
        } else if (update instanceof Api.UpdateEditChannelMessage &&
            update.message instanceof Api.Message && 'peer' in request && getPeerId(request.peer) == getPeerId(update.message.peerId)) {
            schedToMessage.set(update.message.id, update.message);
        } else if (update instanceof Api.UpdateMessagePoll) {
            if ('media' in request && request.media && "poll" in request.media && request?.media.poll.id == update.pollId) {
                if ('peer' in request) {
                    const peerId = getPeer(request.peer) as Api.TypePeer;
                    const poll = update.poll;
                    if (poll && 'id' in request) {
                        const m = new Api.Message({
                            id: request.id,
                            peerId: peerId,
                            media: new Api.MessageMediaPoll({
                                poll: poll,
                                results: update.results
                            }),
                            message: '',
                            date: 0,
                        });
                        // @ts-ignore
                        m._finishInit(this, entities, inputChat);
                        return m;
                    }
                }
            }
        }

    }
    if (!request) {
        return idToMessage;
    }
    let mapping;
    let opposite = new Map();

    if (!("scheduleDate" in request)) {
        mapping = idToMessage;
    } else {
        mapping = schedToMessage;
        opposite = idToMessage;
    }
    let randomId: any = (typeof request == 'number' || isArrayLike(request)) ? request : 'randomId' in request ? request.randomId : undefined;

    if (randomId === undefined) {
        // TODO add logging
        return null;
    }
    if (!isArrayLike(request)) {
        let msg = mapping.get(randomToId.get(randomId));
        if (!msg) {
            msg = opposite.get(randomToId.get(randomId));
        }
        if (!msg) {
            throw new Error(`Request ${request.className} had missing message mapping`)
            // TODO add logging
        }
        return msg;
    }
    if (isArrayLike((randomId))) {

        const maps = [];
        // @ts-ignore
        for (const rnd of randomId) {
            const d = mapping.get(randomToId.get(rnd));
            const o = opposite.get(randomToId.get(rnd));

            maps.push(d ?? o)

        }
        return maps;
    }
}


*/
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWVzc2FnZVBhcnNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vZ3JhbWpzL2NsaWVudC9tZXNzYWdlUGFyc2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsb0NBQTJDO0FBQzNDLDhCQUEwQjtBQU1iLFFBQUEsa0JBQWtCLEdBRTNCO0lBQ0EsSUFBSSxFQUFFLFFBQUcsQ0FBQyxpQkFBaUI7SUFDM0IsSUFBSSxFQUFFLFFBQUcsQ0FBQyxtQkFBbUI7SUFDN0IsSUFBSSxFQUFFLFFBQUcsQ0FBQyxtQkFBbUI7SUFDN0IsR0FBRyxFQUFFLFFBQUcsQ0FBQyxpQkFBaUI7SUFDMUIsS0FBSyxFQUFFLFFBQUcsQ0FBQyxnQkFBZ0I7Q0FDOUIsQ0FBQztBQVNGLFNBQXNCLG1CQUFtQixDQUFDLE1BQXNCLEVBQUUsUUFBaUMsRUFBRSxDQUFTLEVBQUUsSUFBZ0I7O1FBQzVILElBQUk7WUFDQSxRQUFRLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxRQUFHLENBQUMsNkJBQTZCLENBQy9DO2dCQUNJLE1BQU0sRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTTtnQkFDMUIsTUFBTSxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNO2dCQUMxQixNQUFNLEVBQUUsTUFBTSxNQUFNLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQzthQUM1QyxDQUNKLENBQUE7WUFDRCxPQUFPLElBQUksQ0FBQztTQUNmO1FBQUMsT0FBTyxDQUFDLEVBQUU7WUFDUixPQUFPLEtBQUssQ0FBQztTQUNoQjtJQUNMLENBQUM7Q0FBQTtBQWJELGtEQWFDO0FBRUQsU0FBZ0IsaUJBQWlCLENBQUMsTUFBc0IsRUFBRSxPQUFlLEVBQUUsU0FBYztJQUNyRixJQUFJLENBQUMsU0FBUyxFQUFFO1FBQ1osU0FBUyxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUM7S0FDaEM7U0FBTSxJQUFJLE9BQU8sU0FBUyxLQUFLLFFBQVEsRUFBRTtRQUN0QyxTQUFTLEdBQUcseUJBQWlCLENBQUMsU0FBUyxDQUFDLENBQUM7S0FDNUM7SUFDRCxJQUFJLENBQUMsU0FBUyxFQUFFO1FBQ1osT0FBTyxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsQ0FBQTtLQUN2QjtJQUNELE9BQU8sU0FBUyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUNwQyxDQUFDO0FBVkQsOENBVUM7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQTZHRSJ9