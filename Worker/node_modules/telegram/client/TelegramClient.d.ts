/// <reference types="node" />
import { TelegramBaseClient } from "./telegramBaseClient";
import * as authMethods from "./auth";
import * as downloadMethods from "./downloads";
import * as parseMethods from "./messageParse";
import * as messageMethods from "./messages";
import * as uploadMethods from "./uploads";
import * as chatMethods from "./chats";
import type { ButtonLike, EntityLike } from "../define";
import { Api } from "../tl";
import type { EventBuilder } from "../events/common";
import { MTProtoSender, UpdateConnectionState } from "../network";
import { DownloadMediaInterface } from "./downloads";
export declare class TelegramClient extends TelegramBaseClient {
    start(authParams: authMethods.UserAuthParams | authMethods.BotAuthParams): Promise<void>;
    checkAuthorization(): Promise<boolean>;
    signInUser(apiCredentials: authMethods.ApiCredentials, authParams: authMethods.UserAuthParams): Promise<Api.TypeUser>;
    signInUserWithQrCode(apiCredentials: authMethods.ApiCredentials, authParams: authMethods.UserAuthParams): Promise<Api.TypeUser>;
    sendCode(apiCredentials: authMethods.ApiCredentials, phoneNumber: string, forceSMS?: boolean): Promise<{
        phoneCodeHash: string;
        isCodeViaApp: boolean;
    }>;
    signInWithPassword(apiCredentials: authMethods.ApiCredentials, authParams: authMethods.UserAuthParams): Promise<Api.TypeUser>;
    signInBot(apiCredentials: authMethods.ApiCredentials, authParams: authMethods.BotAuthParams): Promise<Api.TypeUser>;
    authFlow(apiCredentials: authMethods.ApiCredentials, authParams: authMethods.UserAuthParams | authMethods.BotAuthParams): Promise<void>;
    inlineQuery(bot: EntityLike, query: string, entity?: Api.InputPeerSelf | null, offset?: string, geoPoint?: Api.GeoPoint): Promise<import("../tl/custom/inlineResults").InlineResults<Api.messages.BotResults>>;
    buildReplyMarkup(buttons: Api.TypeReplyMarkup | undefined | ButtonLike | ButtonLike[] | ButtonLike[][], inlineOnly?: boolean): Api.TypeReplyMarkup | undefined;
    downloadFile(inputLocation: Api.TypeInputFileLocation, fileParams: downloadMethods.DownloadFileParams): Promise<Buffer>;
    _downloadPhoto(photo: Api.MessageMediaPhoto | Api.Photo, args: DownloadMediaInterface): Promise<Buffer>;
    _downloadCachedPhotoSize(size: Api.PhotoCachedSize | Api.PhotoStrippedSize): Buffer;
    _downloadDocument(media: Api.MessageMediaDocument | Api.Document, args: DownloadMediaInterface): Promise<Buffer>;
    _downloadContact(contact: Api.MessageMediaContact, args: DownloadMediaInterface): Promise<Buffer>;
    _downloadWebDocument(webDocument: Api.WebDocument | Api.WebDocumentNoProxy, args: DownloadMediaInterface): Promise<Buffer>;
    downloadMedia(messageOrMedia: Api.Message | Api.TypeMessageMedia, args: DownloadMediaInterface): Promise<Buffer>;
    get parseMode(): parseMethods.ParseInterface;
    setParseMode(mode: string | parseMethods.ParseInterface): void;
    _replaceWithMention(entities: Api.TypeMessageEntity[], i: number, user: EntityLike): Promise<boolean>;
    _parseMessageText(message: string, parseMode: any): any;
    iterMessages(entity: EntityLike, params: messageMethods.IterMessagesParams): messageMethods._MessagesIter | messageMethods._IDsIter;
    getMessages(entity: EntityLike, params: messageMethods.IterMessagesParams): Promise<import("../Helpers").TotalList<import("../tl/custom/message").Message>>;
    sendMessage(entity: EntityLike, params: messageMethods.SendMessageParams): Promise<Api.TypeUpdates>;
    iterParticipants(entity: EntityLike, params: chatMethods.IterParticipantsParams): chatMethods._ParticipantsIter;
    getParticipants(entity: EntityLike, params: chatMethods.IterParticipantsParams): Promise<import("../Helpers").TotalList<Api.User>>;
    on(event: any): (f: CallableFunction) => CallableFunction;
    addEventHandler(callback: CallableFunction, event?: EventBuilder): void;
    removeEventHandler(callback: CallableFunction, event: EventBuilder): void;
    listEventHandlers(): [EventBuilder, CallableFunction][];
    _handleUpdate(update: Api.TypeUpdate | number): void;
    _processUpdate(update: any, others: any, entities?: any): void;
    _dispatchUpdate(args: {
        update: UpdateConnectionState | any;
    }): Promise<void>;
    _updateLoop(): Promise<void>;
    uploadFile(fileParams: uploadMethods.UploadFileParams): Promise<Api.InputFile | Api.InputFileBig>;
    sendFile(entity: EntityLike, params: uploadMethods.SendFileInterface): Promise<Api.TypeUpdates>;
    invoke<R extends Api.AnyRequest>(request: R): Promise<R['__response']>;
    getMe(inputPeer?: boolean): Promise<Api.User | Api.InputPeerUser>;
    isBot(): Promise<boolean | undefined>;
    isUserAuthorized(): Promise<boolean>;
    getEntity(entity: any): Promise<import("../define").Entity>;
    getInputEntity(peer: EntityLike): Promise<Api.TypeInputPeer>;
    getPeerId(peer: EntityLike, addMark?: boolean): Promise<number>;
    _getEntityFromString(string: string): Promise<Api.TypeUser | Api.InputPeerUser | Api.TypeChat>;
    _getPeer(peer: EntityLike): Promise<Api.PeerUser | Api.PeerChat | Api.PeerChannel | undefined>;
    _getInputDialog(dialog: any): Promise<any>;
    _getInputNotify(notify: any): Promise<any>;
    connect(): Promise<void>;
    _switchDC(newDc: number): Promise<void>;
    _createExportedSender(dcId: number, retries: number): Promise<MTProtoSender | null>;
    getDC(dcId: number): Promise<{
        id: number;
        ipAddress: string;
        port: number;
    }>;
    removeSender(dcId: number): void;
    _borrowExportedSender(dcId: number, retries?: number): Promise<any>;
}
