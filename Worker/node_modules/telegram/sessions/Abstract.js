"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Session = void 0;
class Session {
    constructor() {
    }
    /**
     * Creates a clone of this session file
     * @param toInstance {Session|null}
     * @returns {Session}
     */
    /* CONTEST
    clone(toInstance = null) {
        return toInstance || new this.constructor()
    }*/
    /**
     * Sets the information of the data center address and port that
     * the library should connect to, as well as the data center ID,
     * which is currently unused.
     * @param dcId {number}
     * @param serverAddress {string}
     * @param port {number}
     */
    setDC(dcId, serverAddress, port) {
        throw new Error('Not implemented');
    }
    /**
     * Returns the currently-used data center ID.
     */
    get dcId() {
        throw new Error('Not Implemented');
    }
    /**
     * Returns the server address where the library should connect to.
     */
    get serverAddress() {
        throw new Error('Not Implemented');
    }
    /**
     * Returns the port to which the library should connect to.
     */
    get port() {
        throw new Error('Not Implemented');
    }
    /**
     * Returns an ``AuthKey`` instance associated with the saved
     * data center, or `None` if a new one should be generated.
     */
    get authKey() {
        throw new Error('Not Implemented');
    }
    /**
     * Sets the ``AuthKey`` to be used for the saved data center.
     * @param value
     */
    set authKey(value) {
        throw new Error('Not Implemented');
    }
    /**
     * Called before using the session
     */
    load() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('Not Implemented');
        });
    }
    /**
     *  sets auth key for a dc
     */
    setAuthKey(authKey, dcId) {
        throw new Error('Not Implemented');
    }
    /**
     *  gets auth key for a dc
     */
    getAuthKey(dcId) {
        throw new Error('Not Implemented');
    }
    /**
     *
     * @param key
     */
    getInputEntity(key) {
        throw new Error('Not Implemented');
    }
    /**
     * Returns an ID of the takeout process initialized for this session,
     * or `None` if there's no were any unfinished takeout requests.
     */
    /*CONTEST
    get takeoutId() {
        throw new Error('Not Implemented')
    }
    */
    /**
     * Sets the ID of the unfinished takeout process for this session.
     * @param value
     */
    /*CONTEST
    set takeoutId(value) {
        throw new Error('Not Implemented')
    }
    */
    /**
     * Returns the ``UpdateState`` associated with the given `entity_id`.
     * If the `entity_id` is 0, it should return the ``UpdateState`` for
     * no specific channel (the "general" state). If no state is known
     * it should ``return None``.
     * @param entityId
     */
    /*CONTEST
    getUpdateState(entityId) {
        throw new Error('Not Implemented')
    }

     */
    /**
     * Sets the given ``UpdateState`` for the specified `entity_id`, which
     * should be 0 if the ``UpdateState`` is the "general" state (and not
     * for any specific channel).
     * @param entityId
     * @param state
     */
    /*CONTEST
    setUpdateState(entityId, state) {
        throw new Error('Not Implemented')
    }

     */
    /**
     * Called on client disconnection. Should be used to
     * free any used resources. Can be left empty if none.
     */
    /*CONTEST
    close() {

    }

     */
    /**
     * called whenever important properties change. It should
     * make persist the relevant session information to disk.
     */
    save() {
        throw new Error('Not Implemented');
    }
    /**
     * Called upon client.log_out(). Should delete the stored
     * information from disk since it's not valid anymore.
     */
    delete() {
        throw new Error('Not Implemented');
    }
    /**
     * Lists available sessions. Not used by the library itself.
     */
    /*CONTEST
    listSessions() {
        throw new Error('Not Implemented')
    }

     */
    /**
     * Processes the input ``TLObject`` or ``list`` and saves
     * whatever information is relevant (e.g., ID or access hash).
     * @param tlo
     */
    processEntities(tlo) {
        throw new Error('Not Implemented');
    }
}
exports.Session = Session;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQWJzdHJhY3QuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9ncmFtanMvc2Vzc2lvbnMvQWJzdHJhY3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBSUEsTUFBYSxPQUFPO0lBQ2hCO0lBRUEsQ0FBQztJQUVEOzs7O09BSUc7SUFFSDs7O09BR0c7SUFFSDs7Ozs7OztPQU9HO0lBQ0gsS0FBSyxDQUFDLElBQVksRUFBRSxhQUFxQixFQUFFLElBQVk7UUFDbkQsTUFBTSxJQUFJLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxDQUFBO0lBQ3RDLENBQUM7SUFFRDs7T0FFRztJQUNILElBQUksSUFBSTtRQUNKLE1BQU0sSUFBSSxLQUFLLENBQUMsaUJBQWlCLENBQUMsQ0FBQTtJQUN0QyxDQUFDO0lBRUQ7O09BRUc7SUFDSCxJQUFJLGFBQWE7UUFDYixNQUFNLElBQUksS0FBSyxDQUFDLGlCQUFpQixDQUFDLENBQUE7SUFDdEMsQ0FBQztJQUVEOztPQUVHO0lBQ0gsSUFBSSxJQUFJO1FBQ0osTUFBTSxJQUFJLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxDQUFBO0lBQ3RDLENBQUM7SUFFRDs7O09BR0c7SUFDSCxJQUFJLE9BQU87UUFDUCxNQUFNLElBQUksS0FBSyxDQUFDLGlCQUFpQixDQUFDLENBQUE7SUFDdEMsQ0FBQztJQUVEOzs7T0FHRztJQUNILElBQUksT0FBTyxDQUFDLEtBQTBCO1FBQ2xDLE1BQU0sSUFBSSxLQUFLLENBQUMsaUJBQWlCLENBQUMsQ0FBQTtJQUN0QyxDQUFDO0lBRUQ7O09BRUc7SUFDRyxJQUFJOztZQUNOLE1BQU0sSUFBSSxLQUFLLENBQUMsaUJBQWlCLENBQUMsQ0FBQTtRQUV0QyxDQUFDO0tBQUE7SUFFRDs7T0FFRztJQUNILFVBQVUsQ0FBQyxPQUFpQixFQUFFLElBQWE7UUFDdkMsTUFBTSxJQUFJLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxDQUFBO0lBQ3RDLENBQUM7SUFFRDs7T0FFRztJQUVILFVBQVUsQ0FBQyxJQUFhO1FBQ3BCLE1BQU0sSUFBSSxLQUFLLENBQUMsaUJBQWlCLENBQUMsQ0FBQTtJQUN0QyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsY0FBYyxDQUFDLEdBQWU7UUFDMUIsTUFBTSxJQUFJLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxDQUFBO0lBQ3RDLENBQUM7SUFDRDs7O09BR0c7SUFDSDs7OztNQUlFO0lBQ0Y7OztPQUdHO0lBQ0g7Ozs7TUFJRTtJQUNGOzs7Ozs7T0FNRztJQUNIOzs7OztPQUtHO0lBRUg7Ozs7OztPQU1HO0lBQ0g7Ozs7O09BS0c7SUFFSDs7O09BR0c7SUFFSDs7Ozs7T0FLRztJQUVIOzs7T0FHRztJQUNILElBQUk7UUFDQSxNQUFNLElBQUksS0FBSyxDQUFDLGlCQUFpQixDQUFDLENBQUE7SUFDdEMsQ0FBQztJQUVEOzs7T0FHRztJQUVILE1BQU07UUFDRixNQUFNLElBQUksS0FBSyxDQUFDLGlCQUFpQixDQUFDLENBQUE7SUFDdEMsQ0FBQztJQUVEOztPQUVHO0lBRUg7Ozs7O09BS0c7SUFFSDs7OztPQUlHO0lBQ0gsZUFBZSxDQUFDLEdBQVE7UUFDcEIsTUFBTSxJQUFJLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxDQUFBO0lBQ3RDLENBQUM7Q0FlSjtBQTNNRCwwQkEyTUMifQ==