"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createHash = exports.pbkdf2Sync = exports.Hash = exports.randomBytes = exports.createCipheriv = exports.createDecipheriv = exports.CTR = exports.Counter = void 0;
const aes_1 = __importDefault(require("@cryptography/aes"));
const converters_1 = require("./converters");
const words_1 = require("./words");
class Counter {
    constructor(initialValue) {
        this._counter = Buffer.from(initialValue);
    }
    increment() {
        for (let i = 15; i >= 0; i--) {
            if (this._counter[i] === 255) {
                this._counter[i] = 0;
            }
            else {
                this._counter[i]++;
                break;
            }
        }
    }
}
exports.Counter = Counter;
class CTR {
    constructor(key, counter) {
        if (!(counter instanceof Counter)) {
            counter = new Counter(counter);
        }
        this._counter = counter;
        this._remainingCounter = undefined;
        this._remainingCounterIndex = 16;
        this._aes = new aes_1.default(words_1.getWords(key));
    }
    update(plainText) {
        return this.encrypt(plainText);
    }
    encrypt(plainText) {
        const encrypted = Buffer.from(plainText);
        for (let i = 0; i < encrypted.length; i++) {
            if (this._remainingCounterIndex === 16) {
                this._remainingCounter = Buffer.from(converters_1.i2ab(this._aes.encrypt(converters_1.ab2i(this._counter._counter))));
                this._remainingCounterIndex = 0;
                this._counter.increment();
            }
            if (this._remainingCounter) {
                encrypted[i] ^= this._remainingCounter[this._remainingCounterIndex++];
            }
        }
        return encrypted;
    }
}
exports.CTR = CTR;
// endregion
function createDecipheriv(algorithm, key, iv) {
    if (algorithm.includes('ECB')) {
        throw new Error('Not supported');
    }
    else {
        return new CTR(key, iv);
    }
}
exports.createDecipheriv = createDecipheriv;
function createCipheriv(algorithm, key, iv) {
    if (algorithm.includes('ECB')) {
        throw new Error('Not supported');
    }
    else {
        return new CTR(key, iv);
    }
}
exports.createCipheriv = createCipheriv;
function randomBytes(count) {
    const bytes = new Uint8Array(count);
    crypto.getRandomValues(bytes);
    return bytes;
}
exports.randomBytes = randomBytes;
class Hash {
    constructor(algorithm) {
        this.algorithm = algorithm;
    }
    update(data) {
        //We shouldn't be needing new Uint8Array but it doesn't
        //work without it
        this.data = new Uint8Array(data);
    }
    digest() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.data) {
                if (this.algorithm === 'sha1') {
                    return Buffer.from(yield self.crypto.subtle.digest('SHA-1', this.data));
                }
                else if (this.algorithm === 'sha256') {
                    return Buffer.from(yield self.crypto.subtle.digest('SHA-256', this.data));
                }
            }
        });
    }
}
exports.Hash = Hash;
function pbkdf2Sync(password, salt, iterations) {
    return __awaiter(this, void 0, void 0, function* () {
        const passwordKey = yield crypto.subtle.importKey('raw', password, { name: 'PBKDF2' }, false, ['deriveBits']);
        return Buffer.from(yield crypto.subtle.deriveBits({
            name: 'PBKDF2',
            hash: 'SHA-512', salt, iterations,
        }, passwordKey, 512));
    });
}
exports.pbkdf2Sync = pbkdf2Sync;
function createHash(algorithm) {
    return new Hash(algorithm);
}
exports.createHash = createHash;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3J5cHRvLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vZ3JhbWpzL2NyeXB0by9jcnlwdG8udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsNERBQWlEO0FBQ2pELDZDQUF3QztBQUN4QyxtQ0FBaUM7QUFFakMsTUFBYSxPQUFPO0lBR2hCLFlBQVksWUFBaUI7UUFDekIsSUFBSSxDQUFDLFFBQVEsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFBO0lBRTdDLENBQUM7SUFFRCxTQUFTO1FBQ0wsS0FBSyxJQUFJLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUMxQixJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEtBQUssR0FBRyxFQUFFO2dCQUMxQixJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQTthQUN2QjtpQkFBTTtnQkFDSCxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7Z0JBQ25CLE1BQUs7YUFDUjtTQUNKO0lBQ0wsQ0FBQztDQUNKO0FBbEJELDBCQWtCQztBQUVELE1BQWEsR0FBRztJQU1aLFlBQVksR0FBVyxFQUFFLE9BQVk7UUFFakMsSUFBSSxDQUFDLENBQUMsT0FBTyxZQUFZLE9BQU8sQ0FBQyxFQUFFO1lBQy9CLE9BQU8sR0FBRyxJQUFJLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQTtTQUNqQztRQUVELElBQUksQ0FBQyxRQUFRLEdBQUcsT0FBTyxDQUFDO1FBRXhCLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxTQUFTLENBQUM7UUFDbkMsSUFBSSxDQUFDLHNCQUFzQixHQUFHLEVBQUUsQ0FBQztRQUVqQyxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksYUFBRyxDQUFDLGdCQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQTtJQUN0QyxDQUFD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