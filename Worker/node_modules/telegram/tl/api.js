"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const bigInt = require('big-integer');
const { generateRandomBytes, readBigIntFromBuffer, isArrayLike } = require('../Helpers');
function generateRandomBigInt() {
    return readBigIntFromBuffer(generateRandomBytes(8), false);
}
const { parseTl, serializeBytes, serializeDate, } = require('./generationHelpers');
const { IS_NODE, toSignedLittleBuffer } = require('../Helpers');
let tlContent, schemeContent;
if (IS_NODE) {
    const fs = require('fs');
    tlContent = fs.readFileSync(__dirname + '/static/api.tl', 'utf-8');
    schemeContent = fs.readFileSync(__dirname + '/static/schema.tl', 'utf-8');
}
else {
    tlContent = require('./static/api.tl').default;
    schemeContent = require('./static/schema.tl').default;
}
const NAMED_AUTO_CASTS = new Set([
    'chatId,int',
]);
const NAMED_BLACKLIST = new Set([
    'discardEncryption',
]);
const AUTO_CASTS = new Set([
    'InputPeer',
    'InputChannel',
    'InputUser',
    'InputDialogPeer',
    'InputNotifyPeer',
    'InputMedia',
    'InputPhoto',
    'InputMessage',
    'InputDocument',
    'InputChatPhoto',
]);
class CastError extends Error {
    constructor(objectName, expected, actual, ...params) {
        // Pass remaining arguments (including vendor specific ones) to parent constructor
        const message = 'Found wrong type for ' + objectName + '. expected ' + expected + ' but received ' + actual;
        super(message, ...params);
        // Maintains proper stack trace for where our error was thrown (only available on V8)
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, CastError);
        }
        this.name = 'CastError';
        // Custom debugging information
    }
}
const CACHING_SUPPORTED = typeof self !== 'undefined' && self.localStorage !== undefined;
const CACHE_KEY = 'GramJs:apiCache';
function buildApiFromTlSchema() {
    let definitions;
    const fromCache = CACHING_SUPPORTED && loadFromCache();
    if (fromCache) {
        definitions = fromCache;
    }
    else {
        definitions = loadFromTlSchemas();
        if (CACHING_SUPPORTED) {
            localStorage.setItem(CACHE_KEY, JSON.stringify(definitions));
        }
    }
    return createClasses('all', definitions);
}
function loadFromCache() {
    const jsonCache = localStorage.getItem(CACHE_KEY);
    return jsonCache && JSON.parse(jsonCache);
}
function loadFromTlSchemas() {
    const [constructorParamsApi, functionParamsApi] = extractParams(tlContent);
    const [constructorParamsSchema, functionParamsSchema] = extractParams(schemeContent);
    const constructors = [].concat(constructorParamsApi, constructorParamsSchema);
    const requests = [].concat(functionParamsApi, functionParamsSchema);
    return [].concat(constructors, requests);
}
function extractParams(fileContent) {
    const f = parseTl(fileContent, 109);
    const constructors = [];
    const functions = [];
    for (const d of f) {
        d.isFunction ? functions.push(d) : constructors.push(d);
    }
    return [constructors, functions];
}
function argToBytes(x, type) {
    switch (type) {
        case 'int':
            const i = Buffer.alloc(4);
            i.writeInt32LE(x, 0);
            return i;
        case 'long':
            return toSignedLittleBuffer(x, 8);
        case 'int128':
            return toSignedLittleBuffer(x, 16);
        case 'int256':
            return toSignedLittleBuffer(x, 32);
        case 'double':
            const d = Buffer.alloc(8);
            d.writeDoubleLE(x, 0);
            return d;
        case 'string':
            return serializeBytes(x);
        case 'Bool':
            return x ? Buffer.from('b5757299', 'hex') : Buffer.from('379779bc', 'hex');
        case 'true':
            return Buffer.alloc(0);
        case 'bytes':
            return serializeBytes(x);
        case 'date':
            return serializeDate(x);
        default:
            return x.getBytes();
    }
}
function getInputFromResolve(utils, client, peer, peerType) {
    return __awaiter(this, void 0, void 0, function* () {
        switch (peerType) {
            case 'InputPeer':
                return utils.getInputPeer(yield client.getInputEntity(peer));
            case 'InputChannel':
                return utils.getInputChannel(yield client.getInputEntity(peer));
            case 'InputUser':
                return utils.getInputUser(yield client.getInputEntity(peer));
            case 'InputDialogPeer':
                return yield client._getInputDialog(peer);
            case 'InputNotifyPeer':
                return yield client._getInputNotify(peer);
            case 'InputMedia':
                return utils.getInputMedia(peer);
            case 'InputPhoto':
                return utils.getInputPhoto(peer);
            case 'InputMessage':
                return utils.getInputMessage(peer);
            case 'InputDocument':
                return utils.getInputDocument(peer);
            case 'InputChatPhoto':
                return utils.getInputChatPhoto(peer);
            case 'chatId,int':
                return yield client.getPeerId(peer, false);
            default:
                throw new Error('unsupported peer type : ' + peerType);
        }
    });
}
function getArgFromReader(reader, arg) {
    if (arg.isVector) {
        if (arg.useVectorId) {
            reader.readInt();
        }
        const temp = [];
        const len = reader.readInt();
        arg.isVector = false;
        for (let i = 0; i < len; i++) {
            temp.push(getArgFromReader(reader, arg));
        }
        arg.isVector = true;
        return temp;
    }
    else if (arg.flagIndicator) {
        return reader.readInt();
    }
    else {
        switch (arg.type) {
            case 'int':
                return reader.readInt();
            case 'long':
                return reader.readLong();
            case 'int128':
                return reader.readLargeInt(128);
            case 'int256':
                return reader.readLargeInt(256);
            case 'double':
                return reader.readDouble();
            case 'string':
                return reader.tgReadString();
            case 'Bool':
                return reader.tgReadBool();
            case 'true':
                return true;
            case 'bytes':
                return reader.tgReadBytes();
            case 'date':
                return reader.tgReadDate();
            default:
                if (!arg.skipConstructorId) {
                    return reader.tgReadObject();
                }
                else {
                    return api.constructors[arg.type].fromReader(reader);
                }
        }
    }
}
function compareType(value, type) {
    let correct = true;
    switch (type) {
        case 'number':
        case 'string':
        case 'boolean':
            correct = typeof value === type;
            break;
        case 'bigInt':
            correct = bigInt.isInstance(value);
            break;
        case 'true':
            correct = value;
        case 'buffer':
            correct = Buffer.isBuffer(value);
            break;
        case 'date':
            correct = (value && Object.prototype.toString.call(value) === '[object Date]' && !isNaN(value)) || typeof value === 'number';
            break;
        default:
            throw new Error('Unknown type.' + type);
    }
    return correct;
}
function createClasses(classesType, params) {
    const classes = {};
    for (const classParams of params) {
        const { name, constructorId, subclassOfId, argsConfig, namespace, isFunction, result } = classParams;
        const fullName = [namespace, name].join('.').replace(/^\./, '');
        class VirtualClass {
            constructor(args) {
                this.CONSTRUCTOR_ID = constructorId;
                this.SUBCLASS_OF_ID = subclassOfId;
                this.className = fullName;
                this.classType = isFunction ? 'request' : 'constructor';
                args = args || {};
                for (const argName in argsConfig) {
                    if (argName === 'randomId' && !args[argName]) {
                        this[argName] = generateRandomBigInt();
                    }
                    else {
                        this[argName] = args[argName];
                    }
                }
            }
            static fromReader(reader) {
                const args = {};
                for (const argName in argsConfig) {
                    if (argsConfig.hasOwnProperty(argName)) {
                        const arg = argsConfig[argName];
                        if (arg.isFlag) {
                            if (arg.type === 'true') {
                                args[argName] = Boolean(args['flags'] & 1 << arg.flagIndex);
                                continue;
                            }
                            if (args['flags'] & 1 << arg.flagIndex) {
                                args[argName] = getArgFromReader(reader, arg);
                            }
                            else {
                                args[argName] = null;
                            }
                        }
                        else {
                            if (arg.flagIndicator) {
                                arg.name = 'flags';
                            }
                            args[argName] = getArgFromReader(reader, arg);
                        }
                    }
                }
                return new this(args);
            }
            validate() {
                for (const arg in argsConfig) {
                    if (argsConfig.hasOwnProperty(arg)) {
                        const currentValue = this[arg];
                        this.assertType(arg, argsConfig[arg], currentValue);
                    }
                }
            }
            assertType(objectName, object, value) {
                let expected;
                if (object['isVector']) {
                    if (!isArrayLike(value)) {
                        throw new CastError(objectName, 'array', value);
                    }
                    for (const o of value) {
                        this.assertType(objectName, Object.assign(Object.assign({}, object), { isVector: false }), o);
                    }
                }
                else {
                    switch (object['type']) {
                        case 'int':
                            expected = 'number';
                            break;
                        case 'long':
                        case 'int128':
                        case 'int256':
                        case 'double':
                            expected = 'bigInt';
                            break;
                        case 'string':
                            expected = 'string';
                            break;
                        case 'Bool':
                            expected = 'boolean';
                            break;
                        case 'true':
                            expected = 'true';
                            break;
                        case 'bytes':
                            expected = 'buffer';
                            break;
                        case 'date':
                            expected = 'date';
                            break;
                        default:
                            expected = 'object';
                    }
                    if (expected === 'object') {
                        // will be validated in get byte();
                    }
                    else {
                        const isCorrectType = compareType(value, expected);
                        if (isCorrectType !== true) {
                            throw new CastError(objectName, expected, value);
                        }
                    }
                }
            }
            getBytes() {
                // this.validate()
                const idForBytes = this.CONSTRUCTOR_ID;
                const c = Buffer.alloc(4);
                c.writeUInt32LE(idForBytes, 0);
                const buffers = [c];
                for (const arg in argsConfig) {
                    if (argsConfig.hasOwnProperty(arg)) {
                        if (argsConfig[arg].isFlag) {
                            if (this[arg] === false || this[arg] === null || this[arg] === undefined || argsConfig[arg].type === 'true') {
                                continue;
                            }
                        }
                        if (argsConfig[arg].isVector) {
                            if (argsConfig[arg].useVectorId) {
                                buffers.push(Buffer.from('15c4b51c', 'hex'));
                            }
                            const l = Buffer.alloc(4);
                            l.writeInt32LE(this[arg].length, 0);
                            buffers.push(l, Buffer.concat(this[arg].map(x => argToBytes(x, argsConfig[arg].type))));
                        }
                        else if (argsConfig[arg].flagIndicator) {
                            if (!Object.values(argsConfig)
                                .some(f => f.isFlag)) {
                                buffers.push(Buffer.alloc(4));
                            }
                            else {
                                let flagCalculate = 0;
                                for (const f in argsConfig) {
                                    if (argsConfig[f].isFlag) {
                                        if (this[f] === false || this[f] === undefined || this[f] === null) {
                                            flagCalculate |= 0;
                                        }
                                        else {
                                            flagCalculate |= 1 << argsConfig[f].flagIndex;
                                        }
                                    }
                                }
                                const f = Buffer.alloc(4);
                                f.writeUInt32LE(flagCalculate, 0);
                                buffers.push(f);
                            }
                        }
                        else {
                            buffers.push(argToBytes(this[arg], argsConfig[arg].type));
                            if (this[arg] && typeof this[arg].getBytes === 'function') {
                                let boxed = (argsConfig[arg].type.charAt(argsConfig[arg].type.indexOf('.') + 1));
                                boxed = boxed === boxed.toUpperCase();
                                if (!boxed) {
                                    buffers.shift();
                                }
                            }
                        }
                    }
                }
                return Buffer.concat(buffers);
            }
            readResult(reader) {
                if (!isFunction) {
                    throw new Error('`readResult()` called for non-request instance');
                }
                const m = result.match(/Vector<(int|long)>/);
                if (m) {
                    reader.readInt();
                    const temp = [];
                    const len = reader.readInt();
                    if (m[1] === 'int') {
                        for (let i = 0; i < len; i++) {
                            temp.push(reader.readInt());
                        }
                    }
                    else {
                        for (let i = 0; i < len; i++) {
                            temp.push(reader.readLong());
                        }
                    }
                    return temp;
                }
                else {
                    return reader.tgReadObject();
                }
            }
            resolve(client, utils) {
                return __awaiter(this, void 0, void 0, function* () {
                    if (!isFunction) {
                        throw new Error('`resolve()` called for non-request instance');
                    }
                    for (const arg in argsConfig) {
                        if (argsConfig.hasOwnProperty(arg)) {
                            if (!AUTO_CASTS.has(argsConfig[arg].type)) {
                                if (!NAMED_AUTO_CASTS.has(`${argsConfig[arg].name},${argsConfig[arg].type}`)) {
                                    continue;
                                }
                            }
                            if (argsConfig[arg].isFlag) {
                                if (!this[arg]) {
                                    continue;
                                }
                            }
                            if (argsConfig[arg].isVector) {
                                const temp = [];
                                for (const x of this[arg]) {
                                    temp.push(yield getInputFromResolve(utils, client, x, argsConfig[arg].type));
                                }
                                this[arg] = temp;
                            }
                            else {
                                this[arg] = yield getInputFromResolve(utils, client, this[arg], argsConfig[arg].type);
                            }
                        }
                    }
                });
            }
        }
        VirtualClass.CONSTRUCTOR_ID = constructorId;
        VirtualClass.SUBCLASS_OF_ID = subclassOfId;
        VirtualClass.className = fullName;
        VirtualClass.classType = isFunction ? 'request' : 'constructor';
        if (namespace) {
            if (!classes[namespace]) {
                classes[namespace] = {};
            }
            classes[namespace][name] = VirtualClass;
        }
        else {
            classes[name] = VirtualClass;
        }
    }
    return classes;
}
const api = buildApiFromTlSchema();
module.exports = { Api: api };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBpLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vZ3JhbWpzL3RsL2FwaS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUEsTUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFBO0FBR3JDLE1BQU0sRUFBRSxtQkFBbUIsRUFBRSxvQkFBb0IsRUFBRSxXQUFXLEVBQUUsR0FBRyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUE7QUFHeEYsU0FBUyxvQkFBb0I7SUFDekIsT0FBTyxvQkFBb0IsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQTtBQUM5RCxDQUFDO0FBRUQsTUFBTSxFQUNGLE9BQU8sRUFDUCxjQUFjLEVBQ2QsYUFBYSxHQUNoQixHQUFHLE9BQU8sQ0FBQyxxQkFBcUIsQ0FBQyxDQUFBO0FBQ2xDLE1BQU0sRUFBRSxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsR0FBRyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUE7QUFDL0QsSUFBSSxTQUFTLEVBQUUsYUFBYSxDQUFBO0FBQzVCLElBQUksT0FBTyxFQUFFO0lBQ1QsTUFBTSxFQUFFLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFBO0lBRXhCLFNBQVMsR0FBRyxFQUFFLENBQUMsWUFBWSxDQUFDLFNBQVMsR0FBRyxnQkFBZ0IsRUFBRSxPQUFPLENBQUMsQ0FBQTtJQUNsRSxhQUFhLEdBQUcsRUFBRSxDQUFDLFlBQVksQ0FBQyxTQUFTLEdBQUcsbUJBQW1CLEVBQUUsT0FBTyxDQUFDLENBQUE7Q0FDNUU7S0FBTTtJQUNILFNBQVMsR0FBRyxPQUFPLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxPQUFPLENBQUE7SUFDOUMsYUFBYSxHQUFHLE9BQU8sQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDLE9BQU8sQ0FBQTtDQUN4RDtBQUNELE1BQU0sZ0JBQWdCLEdBQUcsSUFBSSxHQUFHLENBQUM7SUFDN0IsWUFBWTtDQUNmLENB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